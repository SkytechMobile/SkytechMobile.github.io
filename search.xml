<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F04%2F21%2FSubjects%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1. 简介Subjects 既是Observer，也是 Observable 说它是Observer，是因为它能够动态地接收新的值。 说它又是一个 Observable，是因为当 Subjects 有了新的值之后，就会通过 Event 将新值发出给他的所有订阅者。一共有五种 Subjects，分别为：PublishSubject、BehaviorSubject、ReplaySubject、Variable、BehaviorRelay。他们之间既有各自的特点，也有相同之处 首先他们都是Observable，他们的订阅者都能收到他们发出的新的 Event。 直到 Subject 发出 .complete 或者 .error 的 Event 后，该 Subject 便终结了，同时它也就不会再发出 .next 事件。 对于那些在 Subject 终结后再订阅他的订阅者，也能收到 subject 发出的一条 .complete 或 .error 的 event，告诉这个新的订阅者它已经终结了。 他们之间最大的区别只是在于：当一个新的订阅者刚订阅它的时候，能不能收到 Subject 以前发出过的旧 Event，如果能的话又能收到多少个。Subject 常用的几个方法： onNext(:)：是 on(.next(:)) 的简便写法。该方法相当于 subject 接收到一个 .next 事件。 onError(:)：是 on(.error(:)) 的简便写法。该方法相当于 subject 接收到一个 .error 事件。 onCompleted()：是 on(.completed) 的简便写法。该方法相当于 subject 接收到一个 .completed 事件。2. PublishSubject2.1 简介 PublishSubject 是最普通的 Subject，它不需要初始值就能创建。 PublishSubject 的订阅者从他们开始订阅的时间点起，可以收到订阅后 Subject 发出的新 Event，而不会收到他们在订阅前已发出的 Event。2.2 时序图 最上面一条是 PublishSubject。 下面两条分别表示两个新的订阅，它们订阅的时间点不同，可以发现 PublishSubject 的订阅者只能收到他们订阅后的 Event。12345678910111213141516171819202122232425262728293031323334353637383940let disposeBag = DisposeBag() //创建一个PublishSubjectlet subject = PublishSubject&lt;String&gt;() //由于当前没有任何订阅者，所以这条信息不会输出到控制台subject.onNext("111") //第1次订阅subjectsubject.subscribe(onNext: &#123; string in print("第1次订阅：", string)&#125;, onCompleted:&#123; print("第1次订阅：onCompleted")&#125;).disposed(by: disposeBag) //当前有1个订阅，则该信息会输出到控制台subject.onNext("222") //第2次订阅subjectsubject.subscribe(onNext: &#123; string in print("第2次订阅：", string)&#125;, onCompleted:&#123; print("第2次订阅：onCompleted")&#125;).disposed(by: disposeBag) //当前有2个订阅，则该信息会输出到控制台subject.onNext("333") //让subject结束subject.onCompleted() //subject完成后会发出.next事件了。subject.onNext("444") //subject完成后它的所有订阅（包括结束后的订阅），都能收到subject的.completed事件，subject.subscribe(onNext: &#123; string in print("第3次订阅：", string)&#125;, onCompleted:&#123; print("第3次订阅：onCompleted")&#125;).disposed(by: disposeBag) 3. BehaviorSubject3.1 简介 BehaviorSubject 需要通过一个默认初始值来创建。 当一个订阅者来订阅它的时候，这个订阅者会立即收到 BehaviorSubjects 上一个发出的 event。之后就跟正常的情况一样，它也会接收到 BehaviorSubject 之后发出的新的 event。3.2 时序图 最上面一条是 BehaviorSubject。 下面两条分别表示两个新的订阅，它们订阅的时间点不同，可以发现 BehaviorSubject 的订阅者一开始就能收到 BehaviorSubjects 之前发出的一个 Event。1234567891011121314151617181920let disposeBag = DisposeBag() //创建一个BehaviorSubjectlet subject = BehaviorSubject(value: "111") //第1次订阅subjectsubject.subscribe &#123; event in print("第1次订阅：", event)&#125;.disposed(by: disposeBag) //发送next事件subject.onNext("222") //发送error事件subject.onError(NSError(domain: "local", code: 0, userInfo: nil)) //第2次订阅subjectsubject.subscribe &#123; event in print("第2次订阅：", event)&#125;.disposed(by: disposeBag) 4. ReplaySubject4.1 简介 ReplaySubject 在创建时候需要设置一个 bufferSize，表示它对于它发送过的 event 的缓存个数。 比如一个 ReplaySubject 的 bufferSize 设置为 2，它发出了 3 个 .next 的 event，那么它会将后两个（最近的两个）event 给缓存起来。此时如果有一个 subscriber 订阅了这个 ReplaySubject，那么这个 subscriber 就会立即收到前面缓存的两个 .next 的 event。 如果一个 subscriber 订阅已经结束的 ReplaySubject，除了会收到缓存的 .next 的 event 外，还会收到那个终结的 .error 或者 .complete 的 event。4.2 时序图 最上面一条是 ReplaySubject（bufferSize 设为为 2）。 下面两条分别表示两个新的订阅，它们订阅的时间点不同。可以发现 ReplaySubject 的订阅者一开始就能收到 ReplaySubject 之前发出的两个 Event（如果有的话）。123456789101112131415161718192021222324252627282930let disposeBag = DisposeBag() //创建一个bufferSize为2的ReplaySubjectlet subject = ReplaySubject&lt;String&gt;.create(bufferSize: 2) //连续发送3个next事件subject.onNext("111")subject.onNext("222")subject.onNext("333") //第1次订阅subjectsubject.subscribe &#123; event in print("第1次订阅：", event)&#125;.disposed(by: disposeBag) //再发送1个next事件subject.onNext("444") //第2次订阅subjectsubject.subscribe &#123; event in print("第2次订阅：", event)&#125;.disposed(by: disposeBag) //让subject结束subject.onCompleted() //第3次订阅subjectsubject.subscribe &#123; event in print("第3次订阅：", event)&#125;.disposed(by: disposeBag) 5. Variable(废弃)5.1 简介 Variable 其实就是对 BehaviorSubject 的封装，所以它也必须要通过一个默认的初始值进行创建。 Variable 具有 BehaviorSubject 的功能，能够向它的订阅者发出上一个 event 以及之后新创建的 event。 不同的是，Variable 还把会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送 .complete 的 event，不需要也不能手动给 Variables 发送 completed 或者 error 事件来结束它。 简单地说就是 Variable 有一个 value 属性，我们改变这个 value 属性的值就相当于调用一般 Subjects 的 onNext() 方法，而这个最新的 onNext() 的值就被保存在 value 属性里了，直到我们再次修改它。 注意：Variables 本身没有 subscribe() 方法，但是所有 Subjects 都有一个 asObservable() 方法。我们可以使用这个方法返回这个 Variable 的 Observable 类型，拿到这个Observable 类型我们就能订阅它了。 5.2 时序图 12345678910111213141516171819202122232425262728293031323334import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let disposeBag = DisposeBag() //创建一个初始值为111的Variable let variable = Variable("111") //修改value值 variable.value = "222" //第1次订阅 variable.asObservable().subscribe &#123; print("第1次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 variable.value = "333" //第2次订阅 variable.asObservable().subscribe &#123; print("第2次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 variable.value = "444" &#125;&#125; 注意：由于 Variable 对象在 viewDidLoad() 方法内初始化，所以它的生命周期就被限制在该方法内。当这个方法执行完毕后，这个 Variable 对象就会被销毁，同时它也就自动地向它的所有订阅者发出 .completed 事件 5. BehaviorRelay5.1 简介 BehaviorRelay 是作为 Variable 的替代者出现的。它的本质其实也是对 BehaviorSubject 的封装，所以它也必须要通过一个默认的初始值进行创建。 BehaviorRelay 具有 BehaviorSubject 的功能，能够向它的订阅者发出上一个 event 以及之后新创建的 event。 与 BehaviorSubject 不同的是，不需要也不能手动给 BehaviorReply 发送 completed 或者 error 事件来结束它（BehaviorRelay 会在销毁时也不会自动发送 .complete 的 event）。 BehaviorRelay 有一个 value 属性，我们通过这个属性可以获取最新值。而通过它的 accept() 方法可以对值进行修改。上面的 Variable 样例我们可以改用成 BehaviorRelay12345678910111213141516171819202122232425262728293031323334import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let disposeBag = DisposeBag() //创建一个初始值为111的BehaviorRelay let subject = BehaviorRelay&lt;String&gt;(value: "111") //修改value值 subject.accept("222") //第1次订阅 subject.asObservable().subscribe &#123; print("第1次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 subject.accept("333") //第2次订阅 subject.asObservable().subscribe &#123; print("第2次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 subject.accept("444") &#125;&#125; 如果想将新值合并到原值上，可以通过 accept() 方法与 value 属性配合来实现。（这个常用在表格上拉加载功能上，BehaviorRelay 用来保存所有加载到的数据） 12345678910111213141516171819202122232425262728293031323334import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let disposeBag = DisposeBag() //创建一个初始值为包含一个元素的数组的BehaviorRelay let subject = BehaviorRelay&lt;[String]&gt;(value: ["1"]) //修改value值 subject.accept(subject.value + ["2", "3"]) //第1次订阅 subject.asObservable().subscribe &#123; print("第1次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 subject.accept(subject.value + ["4", "5"]) //第2次订阅 subject.asObservable().subscribe &#123; print("第2次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 subject.accept(subject.value + ["6", "7"]) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Viper架构探索实践（一）]]></title>
    <url>%2F2019%2F10%2F17%2FViper%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Viper架构图 VIPER的主要部分简介 View: (视图）： 显示Presenter告知的内容，并将用户输入中继回Presenter。 Interactor: (交互器）：包含用例指定的业务逻辑。 Presenter: (表示层，也可称主持人）：包含用于准备显示内容（如从Interactor接收的）和用于对用户输入做出反应（通过从Interactor请求新数据）的视图逻辑。 Entity: (实体）：包含Interactor使用的基本模型对象。 Routing: (路由）：包含用于描述按哪个顺序显示哪些屏幕的导航逻辑。 这种分离也符合单一责任原则。Interactor负责业务分析师Presenter代表交互设计师View负责视觉设计师 相比MVX相比之前的MVX架构，VIPER多出了两个东西：Interactor（交互器）和Router（路由）。 各部分职责如下： 123456789101112131415161718192021222324- View提供完整的视图，负责视图的组合、布局、更新向Presenter提供更新视图的接口将View相关的事件发送给Presenter- Presenter接收并处理来自View的事件向Interactor请求调用业务逻辑向Interactor提供View中的数据接收并处理来自Interactor的数据回调事件通知View进行更新操作通过Router跳转到其他View- Router提供View之间的跳转功能，减少了模块间的耦合初始化VIPER的各个模块- Interactor维护主要的业务逻辑功能，向Presenter提供现有的业务用例维护、获取、更新Entity当有业务相关的事件发生时，处理事件，并通知Presenter- Entity和Model一样的数据模型 Viper模版代码生成工具推荐两个模版Viperit 支持Swift、SwiftUI 可创建viper架构模版 Generamba 支持OC和Swift 可以创建mvvm、viper模版 了解模版语言Liquidgithub源码：liquidLiquid 模板语言中文文档 Liquid 是一门开源的模板语言，由 Shopify 创造并用 Ruby 实现。它是 Shopify 主题的骨骼，并且被用于加载店铺系统的动态内容。从 2006 年起，Liquid 就被 Shopify 所使用，现在更是被大量 web 应用所使用 Viper架构实践基于Viperit写了一个简单的新闻的demoXCViperitDemo 参考： viper原作者 By Jeff Gilbert and Conrad Stoll 著Architecting iOS Apps with VIPER iOS VIPER架构实践(二)：VIPER详解与实现 iOS架构模式-VIPER]]></content>
      <categories>
        <category>作者：Fan Chason</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用fastlane实现iOS自动化打包上传fir.im和testflight]]></title>
    <url>%2F2019%2F10%2F11%2F%E4%BD%BF%E7%94%A8fastlane%E5%AE%9E%E7%8E%B0iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0fir-im%E5%92%8Ctestflight%2F</url>
    <content type="text"><![CDATA[前言日复一日重复打包工作，是在浪费宝贵的时间 自动化打包工具应运而生，是我们解放双手的利器 fastlane官方文档 github地址 安装fastlane安装最新的Xcode命令行工具 可以Developer Apple上手动下载对应的Command Line Tools 安装 fastlane官方推荐的xcode-select --install 安装时最后结果是*不能安装该软件*** 安装 fastlane放到/usr/local/bin下面 sudo gem install -n /usr/local/bin fastlane 其他的安装方法：（扩展，可跳过） 第一种是通过 Homebrew 软件包管理器来进行安装，第二种就是我们最熟悉的方式，下载安装包来进行安装,第三种是通过 RubyGems 来进行，RubyGems 是一个方便的 Ruby 程序包管理器，可以将一个 Ruby 应用程序打包到一个 Gem 里，作为一个安装单元。 一个 Gem 就是一个封装起来的应用程序或代码库 配置环境变量添加用户环境变量 vim ~/.bash_profile 添加 123...export PATH=/usr/local/bin:$PATH... 保存退出，使用 source ~/.bash_profile 来使配置立即生效 现在在项目根目录下可以使用fastlane了 fastlane使用在项目根目录下初始化fastlane init 四个选项 123456What would you like to use fastlane for?1.Automate screenshots2.Automate beta distribution to TestFlight3.Automate App Store distribution4.Manual setup - manually setup your project to automate your tasks 解释： 12341 自动截屏。（帮助我们截取App的显示到appstore上的 截图）2 自动发布beta到TestFlight上，用于内测。3 自动打包发布到AppStore上。4 手动设置。 上传fir选择的4 初始化成功会生成如下目录 配置相关文件配置Gemfile如果使用cocoapods要加上（注意带上当前安装的pod的版本号，否则会报错） gem &#39;cocoapods&#39;, &#39;~&gt;1.8.3&#39; 执行 bundle install 第一次运行 bundle install 时自动生成 Gemfile.lock 文件。以后每次运行 bundle install 时,如果 Gemfile 中的条目不变 bundle 就不会再次计算 gem 依赖版本号，直接根据 Gemfile.lock 检查和安装 gem。如果出现依赖冲突时可以通过 bundle update 更新 Gemfile.lock 配置Fastfile12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364default_platform(:ios)platform :ios do before_all do # 如果你用 pod install cocoapods end desc "打包上传ipa到fir.im" lane :fir do # 如果你没有申请adhoc证书，sigh会自动帮你申请，并且添加到Xcode里 # sigh(adhoc: true) # 以下两个action来自fastlane-plugin-versioning， # 第一个递增 Build，第二个设定Version。 # 如果你有多个target，就必须指定target的值，否则它会直接找找到的第一个plist修改 # 在这里我建议每一个打的包的Build都要不一样，这样crash了拿到日志，可以对应到ipa上 increment_build_number_in_plist( target: 'TestDemo', build_number: '5' ) increment_version_number_in_plist( target: 'TestDemo', version_number: '1.0' ) # gym用来编译ipa gym( scheme: 'TestDemo', export_method: "ad-hoc", # 指定打包方式 ["app-store", "ad-hoc", "package", "enterprise", "development", "developer-id"] #teamID: "xxxxxx", # developer.apple.com 上查看 xcargs: "-allowProvisioningUpdates", output_directory: './firim', output_name: 'TestDemo.ipa' ) # 上传ipa到fir.im服务器，在fir.im获取firim_api_token firim(firim_api_token: "xxxxxxxxxxxxx") # token 在fir 上查看。 end desc "打包上传testflight/app-store" lane :tf do increment_build_number_in_plist( target: 'TestDemo' ) increment_version_number_in_plist( target: 'TestDemo', version_number: '1.0' ) # gym用来编译ipa gym( scheme: 'TestDemo', export_method: "app-store", # 指定打包方式 #teamID: "xxxxxx", # developer.apple.com 上查看 xcargs: "-allowProvisioningUpdates", output_directory: './testflight', output_name: 'TestDemo.ipa' ) #upload_to_testflight appstore # 上传你的App iTunes Connect endend 关于build_number与version_number 1,version_number、build_number都没有设置，会自动获取项目的version和build版本号，并且都自动加1。例如，fastlane打包前后版本号变化：ver1.0.2（Build 11）-&gt; ver1.0.3（Build 12）；2,version_number设置了、build_number没设置，会自动获取项目build版本号，build版本号+1；3,version_number、build_number都设置了，那打包出来的版本号就是设置的版本号，不会自动+1； 添加两个插件12fastlane add_plugin versioningfastlane add_plugin firim 执行打包上传fir.imfastlane fir fir为Fastfile文件中lane :fir do处设置的名字，可以为别的名字 执行打包成功如下图所示： 根目录下firim文件夹下可看到ipa文件 fir.im应用列表，多了刚上传的项目 上传testFlightfastlane tf 问题 Could not find action, lane or variable ‘increment_build_number_in_plist’… 解决： fastlane add_plugin versioning 参考：https://github.com/SiarheiFedartsou/fastlane-plugin-versioning/issues/20 参考 fastlane 自动打包到 fir.im 的踩坑之路 fastlane ios快读入门文档 fastlane使用说明书 fastlane 在mac上配置iOS自动化上架 iOS 自动打包 - fastlane （一） 和重复劳动说再见-使用fastlane进行iOS打包 macOS/Linux 环境变量设置]]></content>
      <categories>
        <category>作者：Fan Chason</category>
      </categories>
      <tags>
        <tag>自动化打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo和Github搭建技术博客]]></title>
    <url>%2F2019%2F09%2F26%2F%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[准备:nodejs、git、npm、hexo 验证有没有敲命令，eg: npm -v，没有装先去装 npm可通过homebrew安装 brew install npm Hexo安装 npm install hexo-cli -g 开始搭建博客 本地创建一个存放博客文件夹 eg: SkytechMobileBlog 切到SkytechMobileBlog目录下执行初始化 hexo init 然后安装依赖 npm install 生成静态文件 hexo g 创建服务 hexo s hexo常用命令： 命令 含义 hexo init 初始化一个文件夹，它会为这个文件夹配置所有骨架 hexo g 即hexo generate，生成静态文件 hexo s 即hexo server，创建服务 hexo d 即hexo deploy,用于将本地文件发布到github上 hexo n 即hexo new,用于新建一篇文章 现在只是在本地搭建了一个技术博客， 要想把博客内容让所有人都能看到，就得借助Github了，把博客内容部署到Github上去 部署到github GitHub上登录/注册一个账号，创建仓库 如果是团队博客 先New organization，再New repository（名字为xxx.github.io，xxx为organization名称） 如果是个人博客： New repository（名字为xxx.github.io，xxx为github账号） 博客的根目录的_config.yml文件的底部deploy设置为： 1234deploy: type: git repository: https://github.com/SkytechMobile/SkytechMobile.github.io.git branch: master 注意：冒号（:）后都有一个空格。你可以把此段代码复制过去，并把https://github.com/SkytechMobile/SkytechMobile.github.io.git替换为你自己的Github仓库路径 部署 根目录下执行 hexo g hexo d 如果此时报错你可以输入npm install hexo-deployer-git --save来解决 以上都没什么问题的话，访 http://SkytechMobile.github.io/ 就能看到自己的博客了 主题配置Eg: 把主题设置为next，最火的hexo的主题。 下载主题 在跟目录文件夹下输入如下命令下载next主题 git clone https://github.com/iissnan/hexo-theme-next themes/next 设置主题 把SKytechMobileBlog/_config.yml文件称为站点配置 把SKytechMobileBlog/_config.yml文件称为主题配置 下载完成后，将站点配置文件的theme字段的值改为next，重新编译并上传到Github上后，访问博客链接，你就会发现主题已经改成next了 next的默认语言为英文，你可以更改为简体中文，找到并打开站点配置文件，找到language字段，将值改为zh-Hans 这里介绍下站点配置文件部分字段的含义： 12345title: SkytechMobile团队博客 // 博客名称subtitle: // 博客副名称description: // 描述author: 晨之科SDK团队 // 作者language: zh-Hans // 语言 关于写博客一、如何新建博客新建命令 hexo new xxx 执行上面的命令即在source/_posts/目录下新建了名为xxx的md文件和资源文件夹 二、写博客注意点 如何上传带图片的博客？ 团队博客设置作者 可在博客md文件分类字段设置 categories：作者：Fan Chason]]></content>
      <categories>
        <category>作者：Fan Chason</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
